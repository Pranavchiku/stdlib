
{{alias}}( order, N, A, LDA, k1, k2, IPIV, sipiv )
    Performs a series of row interchanges on the matrix `A` using
    pivot indices stored in `IPIV`.

    Indexing is relative to the first index. To introduce an offset, use typed
    array views.

    If `N` is equal to `0`, the function returns `A` unchanged.

    Parameters
    ----------
    order: string
        Row-major (C-style) or column-major (Fortran-style) order. Must be
        either 'row-major' or 'column-major'.

    N: integer
        Number of columns in `A`.

    A: Float64Array
        Matrix.

    LDA: integer
        Stride of the first dimension of `A` (a.k.a., leading dimension of the
        matrix `A`).

    k1: integer
        Index of first row to interchange.

    k2: integer
        Index of last row to interchange.

    IPIV: Int32Array
        Array of pivot indices.

    sipiv: integer
        Index increment for `IPIV`.

    Returns
    -------
    A: Float64Array
        Output array.

    Examples
    --------
    // Standard usage:
    > var IPIV = new {{alias:@stdlib/array/int32}}( [ 2, 0, 1 ] );
    > var A = new {{alias:@stdlib/array/float64}}( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );
    > var ord = 'row-major';
    > {{alias}}( ord, 2, A, 2, 0, 2, IPIV, 1 )
    <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]

    // Advanced indexing:
    > IPIV = new {{alias:@stdlib/array/int32}}( [ 2, 0, 0, 0, 1 ] );
    > A = new {{alias:@stdlib/array/float64}}( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0 ] );
    > {{alias}}( ord, 2, A, 2, 0, 2, IPIV, 2 )
    <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0, 7.0, 8.0, 9.0 ]

    // Using typed array views:
    > var IPIV0 = new {{alias:@stdlib/array/int32}}( [ 0, 2, 0, 1 ] );
    > var A0 = new {{alias:@stdlib/array/float64}}( [ 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );
    > IPIV = new Int32Array( IPIV0.buffer, IPIV0.BYTES_PER_ELEMENT*1 );
    > A = new Float64Array( A0.buffer, A0.BYTES_PER_ELEMENT*1 );
    > {{alias}}( ord, 2, A, 2, 0, 2, IPIV, 1 );
    > A0
    <Float64Array>[ 0.0, 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]


{{alias}}.ndarray( ord, N, A, sa1, sa2, oa, k1, k2, inck, IPIV, sipiv, oipiv )
    Performs a series of row interchanges on the matrix `A` using
    pivot indices stored in `IPIV` and alternative indexing semantics.

    While typed array views mandate a view offset based on the underlying
    buffer, the offset parameters support indexing semantics based on starting
    indices.

    Parameters
    ----------
    ord: string
        Row-major (C-style) or column-major (Fortran-style) order. Must be
        either 'row-major' or 'column-major'.

    N: integer
        Number of columns in `A`.

    A: Float64Array
        Matrix.

    sa1: integer
        Stride of the first dimension of `A`.

    sa2: integer
        Stride of the second dimension of `A`.

    oa: integer
        Index offset for `A`.

    k1: integer
        Index of first row to interchange.

    k2: integer
        Index of last row to interchange.

    inck: integer
        Direction in which to apply pivots (-1 to apply pivots in reverse
        order; otherwise, apply in provided order).

    IPIV: Int32Array
        Array of pivot indices.

    sipiv: integer
        Index increment for `IPIV`.

    oipiv: integer
        Index offset for `IPIV`.

    Returns
    -------
    A: Float64Array
        Output array.

    Examples
    --------
    // Standard usage:
    > var IPIV = new {{alias:@stdlib/array/int32}}( [ 2, 0, 1 ] );
    > var A = new {{alias:@stdlib/array/float64}}( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );
    > var ord = 'row-major';
    > {{alias}}.ndarray( ord, 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 )
    <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]

    // Advanced indexing:
    > IPIV = new {{alias:@stdlib/array/int32}}( [ 2, 0, 1 ] );
    > A = new {{alias:@stdlib/array/float64}}( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );
    > {{alias}}.ndarray( ord, 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 )
    <Float64Array>[ 3.0, 4.0, 1.0, 2.0, 5.0, 6.0 ]

    See Also
    --------
